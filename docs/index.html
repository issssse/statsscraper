<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Visitor Counter</title>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.1.1/dist/chartjs-plugin-annotation.min.js"></script>
</head>
<body>
  <div id="layout">
    <canvas id="chart" aria-label="Visitor counter chart" role="img"></canvas>
    <div class="meta">
      <span id="status" class="badge">Loadingâ€¦</span>
    </div>
    <div class="version" id="version"></div>
  </div>

  <script type="module">
    // Derive raw CSV URL for GitHub Pages or fallback to defaults
    const ownerFromHost = window.location.hostname.split('.')[0] || 'USERNAME';
    const pathParts = window.location.pathname.split('/').filter(Boolean);
    const repoFromPath = pathParts[0] || 'statsscraper';
    const RAW_BASE = `https://raw.githubusercontent.com/${ownerFromHost}/${repoFromPath}/main`;
    const CSV_URL = `${RAW_BASE}/data/visitor_counter.csv`;
    const TZ = "Europe/Stockholm"; // adjust if needed
    const REFRESH_MS = 3 * 60 * 1000;
    const NIGHT_START = 22;
    const NIGHT_END = 6;
    const VERSION = "v2026.02.04";
    const TOOLTIP_MAX_PX = 80;

    let chart;

    async function fetchCsv() {
      const res = await fetch(`${CSV_URL}?t=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
      const text = await res.text();
      return text;
    }

    function parseCsv(text) {
      const lines = text.trim().split(/\r?\n/);
      if (lines.length < 2) return [];
      const rows = lines.slice(1);
      return rows.map((line, idx) => {
        const [ts, val] = line.split(",");
        const raw = Number(val);
        if (!Number.isFinite(raw)) return null;
        const corrected = Math.max(raw - (idx + 1), 0);
        return { t: new Date(ts), raw, corrected };
      }).filter(Boolean);
    }

    function buildNightBoxes(points) {
      if (!points.length) return [];
      const start = new Date(points[0].t);
      const end = new Date(points.at(-1).t);
      const boxes = [];
      const day = new Date(Date.UTC(start.getUTCFullYear(), start.getUTCMonth(), start.getUTCDate()));
      while (day < end) {
        const nightStart = new Date(day);
        nightStart.setUTCHours(NIGHT_START, 0, 0, 0);
        const nightEnd = new Date(day);
        if (NIGHT_START > NIGHT_END) nightEnd.setUTCDate(nightEnd.getUTCDate() + 1);
        nightEnd.setUTCHours(NIGHT_END, 0, 0, 0);
        boxes.push({
          type: 'box',
          xMin: nightStart,
          xMax: nightEnd,
          backgroundColor: 'rgba(0,0,0,0.06)',
          borderWidth: 0,
          drawTime: 'beforeDatasetsDraw'
        });
        day.setUTCDate(day.getUTCDate() + 1);
      }
      return boxes;
    }

    function buildGapBoxes(points, maxHoursGap = 12) {
      if (points.length < 2) return [];
      const boxes = [];
      for (let i = 1; i < points.length; i++) {
        const prev = points[i - 1];
        const curr = points[i];
        const diffHours = (curr.t - prev.t) / 36e5;
        if (diffHours > maxHoursGap) {
          boxes.push({
            type: 'box',
            xMin: prev.t,
            xMax: curr.t,
            backgroundColor: 'rgba(255, 99, 132, 0.12)', // light red gap highlight
            borderWidth: 0,
            drawTime: 'beforeDatasetsDraw',
          });
        }
      }
      return boxes;
    }

    function withGaps(points, maxHoursGap = 12) {
      if (!points.length) return [];
      const out = [{ x: points[0].t, y: points[0].corrected }];
      for (let i = 1; i < points.length; i++) {
        const prev = points[i - 1];
        const curr = points[i];
        const diffHours = (curr.t - prev.t) / 36e5;
        if (diffHours > maxHoursGap) {
          // insert a gap marker to break the line
          out.push({ x: new Date(prev.t.getTime() + 1000), y: null });
        }
        out.push({ x: curr.t, y: curr.corrected });
      }
      return out;
    }

    function render(points) {
      const dataCorrected = withGaps(points, 12);
      const annotations = [
        ...buildNightBoxes(points),
        ...buildGapBoxes(points, 12),
      ];

      const config = {
        type: 'line',
        data: {
          datasets: [
            {
              label: 'Corrected',
              data: dataCorrected,
              borderColor: '#0f8ec7',
              backgroundColor: 'rgba(15,142,199,0.08)',
              tension: 0.15,
              pointRadius: 0,
              borderWidth: 2.4,
              spanGaps: false,
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'nearest', intersect: false },
          scales: {
            x: {
              type: 'time',
              time: { tooltipFormat: 'yyyy-MM-dd HH:mm', unit: 'day', displayFormats: { day: 'MMM d' } },
              ticks: { color: '#334155', maxRotation: 0, autoSkip: true },
              grid: { color: 'rgba(15,23,42,0.08)' }
            },
            y: {
              beginAtZero: true,
              ticks: { color: '#334155' },
              grid: { color: 'rgba(15,23,42,0.08)' }
            }
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: ctx => `${ctx.dataset.label}: ${ctx.formattedValue}`
              }
            },
            annotation: { annotations }
          }
        }
      };

      if (chart) {
        chart.data = config.data;
        chart.options = config.options;
        chart.update();
      } else {
        chart = new Chart(document.getElementById('chart'), config);
        setupHoverThreshold(chart);
      }
    }

    function setupHoverThreshold(chartInstance) {
      const canvas = chartInstance.canvas;
      const clearActive = () => { chartInstance.setActiveElements([]); chartInstance.update(); };

      canvas.addEventListener('mousemove', (event) => {
        const points = chartInstance.getElementsAtEventForMode(event, 'nearest', { intersect: false }, false);
        if (!points.length) {
          clearActive();
          return;
        }
        const p = points[0];
        const { x, y } = p.element;
        const dist = Math.hypot(event.offsetX - x, event.offsetY - y);
        if (dist > TOOLTIP_MAX_PX) {
          clearActive();
        } else {
          chartInstance.setActiveElements([p]);
          chartInstance.update();
        }
      });

      canvas.addEventListener('mouseleave', clearActive);
    }

    async function loadAndRender() {
      try {
        const csv = await fetchCsv();
        const points = parseCsv(csv);
        render(points);
        const updated = points.length ? points.at(-1).t : new Date();
        document.getElementById('status').textContent = `Updated ${updated.toLocaleString(undefined, { timeZone: TZ })}`;
        document.getElementById('version').textContent = VERSION;
      } catch (err) {
        document.getElementById('status').textContent = 'Error loading data';
        console.error(err);
      }
    }

    loadAndRender();
    setInterval(loadAndRender, REFRESH_MS);
  </script>
</body>
</html>
